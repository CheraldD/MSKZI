# Имя исполняемого файла
TARGET = lab1

# Компилятор C++
CXX = g++

# Флаги компилятора: -std=c++11 для поддержки современного стандарта C++,
# -Wall для вывода всех предупреждений, -Wextra для дополнительных предупреждений.
# -g добавляет отладочную информацию.
CXXFLAGS = -std=c++11 -Wall -Wextra -g

# Каталог для временных файлов сборки (объектных файлов)
BUILD_DIR = build

# Автоматический поиск всех исходных .cpp файлов
SRCS = $(wildcard *.cpp)

# Формирование списка объектных файлов.
# Для каждого исходного файла создается соответствующий .o файл в каталоге BUILD_DIR
OBJS = $(addprefix $(BUILD_DIR)/, $(SRCS:.cpp=.o))

# Цель по умолчанию: собрать исполняемый файл
all: $(TARGET)

# Правило для линковки исполняемого файла.
# Оно зависит от всех объектных файлов, которые теперь лежат в BUILD_DIR.
$(TARGET): $(OBJS)
	@echo "Linking target: $@"
	$(CXX) $(CXXFLAGS) -o $@ $^

# Шаблонное правило для компиляции .cpp в .o.
# Говорит, как из файла `some_name.cpp` создать файл `build/some_name.o`
# | $(BUILD_DIR) - это order-only prerequisite. Оно гарантирует,
# что папка $(BUILD_DIR) будет создана до начала компиляции.
$(BUILD_DIR)/%.o: %.cpp | $(BUILD_DIR)
	@echo "Compiling $< -> $@"
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Правило для создания каталога сборки, если он не существует
$(BUILD_DIR):
	@mkdir -p $@

# "Чистая" цель: удаление исполняемого файла и каталога сборки
clean:
	@echo "Cleaning project..."
	@rm -f $(TARGET)
	@rm -rf $(BUILD_DIR)

# Цель для полной пересборки проекта
re: clean all

# Объявление "фантомных" целей, которые не являются реальными файлами
.PHONY: all clean re